并发访问和同步线程【线程安全】：
	*在多线程程序运行环境中，多线程共享资源时有可能会导致该数据计算错误
	
	*同步和异步：异步【类似并联】---多个线程同时执行，每个线程互不相关
				 同步【类似串联】---在执行某一段代码时，必须由某一个线程执行完该代码才能由另外一个线程执行
	
	*解决线程安全问题：线程同步机制【锁】：将多个线程执行时所共享的资源或者对共享资源的操作放在synchronized代码块中
		语法：
			synchronized(锁对象){
				//需要同步执行的代码
				//具有对共享数据进行计算的代码
			}
		锁对象【监视器对象】：可以是java中的任意一个类的对象：它是作为线程执行该代码块中代码的“标志”，只有当线程
				“拥有”此“标志”时，该线程才能执行同步代码块中的代码，否则就在执行完同步代码块之前的代码
				进行等待；
				
				当拥有此“标志”的线程执行完同步代码块中的代码之后会释放该标记，其他线程就会抢夺该标记来
				执行同步代码块中的代码
				
				多个线程要同步执行同步代码块中的代码，则这些线程必须拿到的是同一个锁对象；
				
	小结：锁之前的代码，可看成多线程同时执行，锁里的代码只有抢到锁对象【钥匙】的线程才能执行，执行完后才交给
		  下一个抢到钥匙的线程执行	
		  建议用枚举类对象作锁对象
	
	*单例模式【懒汉模式】中的线程安全问题
	
	*同步方法：如若某个方法在synchronizede{}修饰的同步代码块中，则该方法为同步方法
		语法：public [static] synchronized void show(){
		
		}
		同步方法中的锁对象
			*静态同步方法的锁对象是该方法所处的类的镜像【Class对象】
			*非静态同步方法的锁对象是this
			
		注意：*根据需求编写代码，尽量不要将一个方法中的所有代码都放在同步代码块中
			  *同步的关键在于锁对象是否一致，不同的锁对象就会导致异步	
			  *同步就是每次只允许一个线程执行代码块
			  *当多线程执行的不是同步代码块时，这一段代码就能被好几个线程同时执行
			  
		 
线程等待唤醒机制【线程间的通信】
		【生产者消费者问题】需求：有一个出版社，定义两个关于该出版社的线程，一个用于印刷书籍，一个用于出售书籍
		规则：印刷一本出售一本，如果没有书则需要印刷再出售，如果有书就先出售再印刷
		
			1.如果没有书，消费者等待，生产者线程运行，有书后，唤醒消费者线程
			2.如果有书，生产者等待，消费者运行，没书后，唤醒生产者线程
		
		**异常：IllegalMonitorStateException，出现该异常主要是由于没有在同步代码块中执行wait方法；
			  注意wait,notify,notifyAll只能在同步代码块中使用，并且只能用锁对象调用【当锁对象就是当前
			  对象this时，可直接调用wait()方法】
			  wait()方法是通过递归让线程等待进入阻塞状态的
			  
		
		notify方法只能唤醒在等待状态的任意一个线程，如果生产者在生产，唤醒的恰好是另外一个生产者
		则会造成死锁
		
		解决方法：唤醒全部线程notifyAll

死锁和线程优先级
	*生产者消费者问题
	*嵌套锁