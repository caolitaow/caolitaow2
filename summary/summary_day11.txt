2019，8.4：
	*静态成员的加载是随着类的加载而加载的，并且在执行new关键字之前就加载了
	*包装器类就是Java中的基本数据类型所对应的类类型
	*包装器类型与所对应的基本数据类型可以自由转换
	*除了上述的自由转换你还可以显示转换（Integer I = Integer.valueOf(33)即33转换成Integer类型
反之，	int i = I.intValue()）
	*基本数据类型都是小写，而包装器类型满足java的编程规范，其首字母大写


**Java高级编程2——集合体系
	集合体系
		*集合本身就是一个对象，用于存储其他对象；
		*集合中只能存储引用类型的数据（所以当删除时，当removede形参为基本数据类型时会被认为成索引），不能存储基本类型的数据；当集合中存储基本类型的数据时，JVM会将其自动装箱；
		*集合和数组一样，都可以理解为存储数据的容器
		*Collection集合：学顶层用底层；在单列集合体系中，Collection接口并不是最顶层接口，该接口有一个父接口：Iterable接口【单列集合的最顶层接口】；
		1）Iterator接口：迭代器接口；能够对实现了Iterable接口的集合进行遍历访问【迭代】；
		
		2）Iterable接口的方法：
			// 获取迭代器对象用于迭代遍历【访问】实现了
			// Iterable接口的集合
			Iterator iterator();
			
		3）Iterator接口中的方法：
			hasNext()：	判断有没有下一个元素
			next()：	取出下一个元素
			remove()：	移除当前获取到的元素

		4）Collection接口中的方法：
			add(Object o);		添加元素到集合尾部
			remove(Object o);	移除元素
			size();				获取元素个数
			clear();			清空集合

		5）List接口，该类集合表示有序【向集合中添加元素的顺序和从集合中取出元素的顺序是一致的】可重复的集合，并且集合中的元素可以为null；
			add(int index,Object o);	// 在指定位置添加元素
			remove(int index);			// 移除并返回指定位置上的元素
			set(int index,Object o);	// 修改指定位置的元素
			get(int index);				// 获取指定位置上的元素

		6）ArrayList类：List集合的具体实现，底层的实现原理是可变长的数组；数组中只能添加同一类型的元素，集合在没有指定泛型（声明时没有指定）的情况下可以添加任意引用类型的数据
		此时添加的引用类型，Jvm均把它们当作Object类型
			
			*  ArrayList arl = new ArrayList<Integer>();//泛型和具体类型的关系类似继承关系
				//左边ArrayList就是泛型,右边才是具体类型，这里也是编译运行都看"左边"
		7）List集合元素的迭代遍历：
			*通过索引遍历：
				集合的索引最小值是0，最大值是size-1；

			*增强for循环遍历：
				for(Object o : list){
				}
			*迭代器遍历：

			*JDK8中的Lambda表示遍历：
			 集合名.forEach(System.out::println);