1.JVM的内存结构，Eden和Survivor比例。

见：JVM内存示意图


2.JVM内存为什么要分成新生代，老年代，持久代。

为了更好的实现GC动态回收垃圾，从而更好的分配内存，让内存得到高效利用。每一代对应的GC也不一样。


3.新生代中为什么要分为Eden和Survivor。JVM
中一次完整的GC流程是怎样的，对象如何晋升到老年代，
说说你知道的几种主要的JVM参数。

*Survivor可以看成是进入老年代区的缓冲池，减少进入老年代的对象，因为回收老年代对象所耗费的时
间比新生代的时间长，说白就是提高回收垃圾
的效率，给"垃圾"分类了

*当Eden区满了，Minor GC处理新生代的垃圾，留下来的对象进入Survivor区，进入老年代后，会被
Major GC清理，而且这个处理时间比Minor GC长的多，当老年代区满了后，Full GC就会来一次堆的大清洗


*Eden里放的都是刚创建的对象，Minor GC在进行垃圾回收时，若对象存在，则该对象年龄就加一，当
年龄为15以上（默认）时，就被划分为老年代，需要大量连续内存的对象直接被认定成老年代

*JVM参数：
–XX:NewRatio 用来分配新老年代的内存空间

–XX:SurvivorRatio 用来分配新生代的Eden与Survivor的空间

-ea：开启断言

-Xss：调整JVM栈的大小




4.非常多个线程（可能是不同机器），相互之间需要等待协调，
才能完成某种工作，问怎么设计这种协调方案。

*因为可能需要多台主机运行，即单纯的利用线程同步来协调是，行不通的，不同的线程组间即使锁对象
是一个，也无法进行同行，此时需要借助不受程序控制的第三方文件来控制，即可以利用第三方文件里
的标志来控制处于不同机器的线程间的通信，同一台机器上的线程依然用同步锁【synchronized】解决



5.用过读写锁吗，原理是什么，一般在什么场景下用。
读写锁，当某个资源更新不频繁，经常用于被读时，此时就会用读写锁达到高并发共享，且能修改的目的


6.TCP三次握手和四次挥手的流程，为什么断开连接要4次,
如果握手只有两次，会出现什么。

*见TCP3&4.jpg

*因为服务端表示知道客户端要关闭连接和数据发送完再关连接要分两次告诉客户端【这是我查阅资料自己的理解】

*若只有两次则服务端不知道自己的发送功能和客户端的接收功能是否正常，即可能导致服务端发出的数据
不能被客户端完整的接收到



7.数据库会死锁吗，举一个死锁的例子，mysql怎么解决死锁。

*死锁：多方为了争取彼此的资源，且不肯释放自己的资源导致的循环等待的现象
见lock.jpg

*会，1.当一个事务查询后想修改数据，而此时另一个事务也准备修改此数据，就会发生死锁，因为同一份
数据上的排它锁跟其他事务的锁不兼容
	
	2.当用户A修改表A后(锁住表A)必须还要修改表B，而此时另一个用户B修改完表B(锁住表B)后必须修改表A才有效果
这样谁都得不到想要的资源，谁的事务也无法继续执行，循环等待（这种现象就是死锁）

解决死锁：
*固定事务的修改顺序

*将大事务拆分成小事务，尽量避免因为事务的长时间执行导致死锁发生
*mysql给索引默认加行级锁
*合理降低事务的隔离级别
*合理建立索引，这样可以避免给所查表的每一条记录加锁

8.某个表有近千万数据，CRUD比较慢，如何优化。

*可以做表拆分，减少单表字段数量，优化表结构。
	
	**垂直分表：减少单表字段
	
	**水平分表：减少单表记录条数
	
	**分库分表：将原先一张表的数据分到多个数据库多个表里存储
	

*在保证主键有效的情况下，检查主键索引的字段顺序，使得查询语句中条件的字段顺序和主键索引的
字段顺序保持一致。




9.乐观锁和悲观锁是什么，INNODB的标准行级锁有哪2种，解释其含义。

*乐观锁：事务开始前认为下面的操作不会发生数据冲突，等到要开始进行更新操作时，才会去判断
是否这个数据是否已经被人修改过了
	
	其通常实现为给要修改的数据添上版本号，记录数据版本，当要修改该数据时，将之前查询到的
	版本号与现在查询到的对比，若相等则没人修改，即没发生数据冲突，那就开始真正更新
	
	若发现现在查询的版本号与自己最近一次查询的不一致则不更新
	
*悲观锁：与乐观锁相反，即主动加锁，mysql实现了悲观锁，for update 即加悲观锁，若要修改的字段
上有索引则，只给该行加锁，若没有索引则给表中的每一行加锁

*标准行级锁：
	共享锁（S）：允许一个事务去读一行，阻止其他事务获得相同数据集的排他锁。
	排他锁（X)：允许获得排他锁的事务更新数据，阻止其他事务取得相同数据集的共享读锁和排他写锁。

意向锁是InnoDB自动加的，对于UPDATE、DELETE和INSERT语句，InnoDB会自动给涉及数据集加排他锁（X)；
						对于普通SELECT语句，InnoDB不会加任何锁
						
						可以通过下列方式显示加锁：
						共享锁（S）：SELECT * FROM table_name WHERE … LOCK IN SHARE MODE。
						排他锁（X)：SELECT * FROM table_name WHERE … FOR UPDATE。

S-S，S-X可以共存，但X-S，X-X不能共存

10.ThreadLocal用过么，用途是什么，原理是什么，用的时候要注意什么

*用途：保证每个线程里使用的变量不被其他线程更改

*原理：
	public void set(T value) {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null)
        map.set(this, value);
    else
        createMap(t, value);
}

public T get() {
    Thread t = Thread.currentThread();
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}

ThreadLocalMap getMap(Thread t) {
    return t.threadLocals;
}

*要避免内存泄露

11.如果让你实现一个并发安全的链表，你会怎么做。

*我觉得可以给链表的数据打上一个版此时本号，修改一次版本号加一，这样当多个用户都要操作链表时，
首先比对自己最新的版本号，若一致则直接修改，修改时给具体的数据加锁，若此时另一个用户想修改
则等待。若版本号不一致则不修改，非要修改则获取最新的数据，再加锁修改。


12.synchronized的原理是什么，一般用在什么地方(比如加在静态方法和非静态方法的区别，静 
态方法和非静态方法同时执行的时候会有影响吗)，解释以下名词：重排序，自旋锁，偏向锁，轻 
量级锁，可重入锁，公平锁，非公平锁，乐观锁，悲观锁。

*原理不详？

*一般用来解决线程并发带来的安全问题

*同步静态方法的锁对象是类的锁，而同步非静态方法的锁对象是对象的锁，两者不同，故同时执行
不会影响彼此

	重排序：为了提高性能，处理器和编译器常常会对指令进行重排序，但是单线程不能改变运行结果
			A: int a =1; B: int b = 2; C: int c = a+b;
			
			A与B的执行顺序可以颠倒，但是C必须放在最后
	
	
	自旋锁：：是指当一个线程在获取锁的时候，如果锁已经被其它线程获取，
			  那么该线程将循环等待，然后不断的判断锁是否能够被成功获取，
			  直到获取到锁才会退出循环
	
	
	偏向锁：偏向锁假定将来只有第一个申请锁的线程会使用锁
	
	
	轻量级锁：如果明显存在其他线程申请锁，那么偏向锁将很快膨胀为轻量级锁
	
	
	可重入锁：也叫做递归锁，指的是同一线程 外层函数获得锁之后 ，内层递归函数
			  仍然有获取该锁的代码，但不受影响
	
	公平锁：加锁前检查是否有排队等待的线程，优先排队等待的线程，先来先得
	
	
	非公平锁：加锁时不考虑排队等待问题，直接尝试获取锁，获取不到自动到队尾等待


