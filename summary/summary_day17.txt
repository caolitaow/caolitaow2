断言【assert】
	*断定某件事一定是正确的，如果不正确就产生断言错误；
	*语法：
		assert 布尔表达式[:"错误信息"]；
	*在java中，断言默认是关闭的，需要"-ea"虚拟机开启断言
	
线程【Thread】
	*什么是线程
		进程就是某个应用程序在计算机中运行时所被分配的资源
		
		线程是进程中利用计算机为进程所分配的计算机资源进行数据计算的基本单位；
		
		一个进程中至少包含一个线程，否则该进程无意义；线程具有随机性，当cpu调度到哪个线程就执行
		哪个线程，并且一个cpu在某个时间片之内只能执行一个线程，可理解成线程在抢夺cpu资源,谁抢到
		谁就执行	
		
		多线程：一个进程中多个线程同时执行。
		
		java中的线程体系，Thread类：该类用于表示对线程的描述
						  Runnable接口：实现该接口的类并不是线程类，只是表示具有可运行性
										能够被线程对象调用执行；
	    JVM是多线程，至少开启了main线程和垃圾回收线程
	*自定义线程和创建线程
		继承Thread类：
		    继承该类后，重写该类的run()方法，线程的启动用Thread类中的start()方法
		    不能直接调用run()方法，若直接调用，则不是线程的启动而是普通方法的调用	
					
			java程序在执行时，JVM进程会启动一个线程来执行该程序的主方法，此线程称
			为main线程【主线程】，只有主线程在执行main方法的时候才能执行到main方法
			中定义的创建和启动其他线程的代码，如果启动了多个线程，则这些线程的名字
			是按照启动顺序从"Thread-0"到"Thread-N";  
					  
			在Thread类中的getName()方法返回线程的名字；如果线程代码没有run方法中，在
			不知道当前线程对象时，可以使用Thread类中的静态方法currentThread()获取当前
			执行该方法的线程对象
			
			run()方法中用于定义线程执行的代码；若直接调用run()方法，则相当于普通方法调用
			start()方法启动线程调用run()方法
					  
					  
		实现Runnable接口：
			该接口只有一个方法-run方法；自定义类实现该接口重写run方法，该实现类并不是线程类
			而是让类具有可运行性，从而能让初始化线程类【new Thread(new Runnable()
			{重写run()方法})】
			
		实现Callable接口:该接口中有一个方法call,该方法是具有返回值的，如果线程在执行的过程中调用
		了一个具有返回值的方法，则可以使用该接口创建线程
			
			
	
	*线程的状态【生命周期】
		并发：多个线程同时执行（cpu交叉执行的间隔时间很短）
		并行：多个进程同时执行	
		
		线程中的优先级：java中每个线程都有优先级，高优先级的线程被cpu调度的概率较高，线程的优先
		级被分为10个等级，用int类型的1~10表示，10表示优先级最高，1则最低，5表示线程的默认优先级
		
		Thread类中的方法：
			*static Thread currentThread();获取此代码所在方法正在被执行的线程对象
			*static void sleep(long ms);让执行此代码所在的方法的线程暂时停止执行，等指定的时间之后
			继续执行
		
		Object类中的方法：
			*void notify();唤醒等待的单个线程
			*void notifyAll();唤醒等待的所有线程
			*void wait();在某个方法中调用此方法，则会让执行该方法的线程强制等待【cpu不再调度】，通过
			前两个方法唤醒线程之后才会再次接受cpu的调度
			*void wait(long timeout);如果此代码所在的线程被唤醒或者参数所表示的时间结束，则该线程可以接受
			cpu调度来执行；否则一直处于暂停执行
			
		线程状态：
			新建：创建线程对象之后，线程就处于该状态
			
			就绪【可运行】：新创建的线程对象调用start()方法之后，线程就处于该状态，等待接受
			cpu调度；
			
			运行：cpu正在调度的线程就处于此状态
			
			阻塞：暂时停止执行的线程就处于此状态【调用sleep(时间)，调用wait()，	IO阻塞，join()】，在阻塞条件结束之前是不会接受cpu的调度。			
			
			死亡【消亡】：当线程所执行的方法结束时【调用stop()/线程在执行中发生了异常导致方法结束】，该线程就处于此状态；当某个进程中只要有还在
			执行的线程，则该进程不会结束，即使主线程已经运行结束
					
			注意：
				线程在创建进入就绪状态后只能调用一次start()方法，如若对同一线程对象多次调用start()
				则会出现非法线程状态异常（IllegalThreadStateException）
				
				线程消亡后再次调用start()方法也会出现IllegalThreadStateException
	
				*创建线程对象和调用该线程对象的start()方法不是同一个线程所为*
练习：火车站售票总共有100张票，多个售票窗口同时售票，当所有票卖完就不能售票了
	*并发访问和同步线程【线程安全】
	
	*线程的等待唤醒机制
	
	*死锁和线程优先级	
	
	
