2019,7.31:
	*继承：成员方法可以被重写，成员变量不能（注意java中重写跟修改不同）	
	
		左边说的是等号左边
	*多态：编译看左边，运行看左边（针对成员变量，静态方法）
	       编译看左边，运行看右边（针对非静态成员方法）
	       
	从对象集合出抽象出类来描述对象

	1.static :
		*静态变量/方法又称为类变量/方法
			   
	        *被类的所有对象所共享

		*由类直接调用，不推荐使用对象调用

		*静态数据不能访问非静态数据，因为在类被加载的时候，静态数据会随着类的加载而出现，非静态数据是随着对象的创建而出现

		*静态代码块：伴随着类的加载而执行，并且只执行一次*
		*构造代码块（普通代码块）:伴随着构造器的执行而执行，并且优先于构造器执行
		
		*package:包，1.在java中用于区分同名的类,目录
		*import static:例如：
				import static java.lang.System.out;
				下面调用控制台输出时可直接写成	out.println();
		
		


	2.final： *最终的，不可修改的
		*能修饰变量，方法，类：
		*修饰变量时，不能再修改，因此改变量也称为常量
			1）修饰全局变量时，在定义全局变量时就必须显示初始化
			2）修饰局部变量时，在第一次使用该变量之前必须初始化，并且后面再不能更改该变量
			3）修饰引用类型的变量时，该引用变量存的内存地址不能更改，但是该变量所指向的对象中的数据是可以更改的
			
		*修饰方法时，该方法不能被重写
		*修饰类时，该类不能被继承例如String
		

	3.访问权限修饰符（public > default > protected > private ）：
		*private可以修饰内部类，不能修饰其他的类，只能在本类中访问
		*default:什么都不写,如：int y;只要不同包就不能访问
		*protected:只要不同包就不能访问
		*

	4.抽象类：
		*从类的集合中抽象出抽象类来描述类,固定不变的方法可以实现，随类的改变而改变的方法则不能实现（没有方法），即只能声明

		*包含抽象方法的类一定是抽象类
		*抽象类中也有构造器，但是不能直接创建对象
		*抽象类只能通过子类继承，创建子类对象调用抽象类中的方法,也可以使用匿名内部类继承抽象类
		*继承抽象类时，抽象类中必须要有无参构造器（若默认构造器未消失也行，显示定义构造器，默认的那个构造器就消失了）
	5.接口：
		*从抽象类的集合中抽象出接口来描述抽象类
		*接口中的方法全部都是抽象方法 public abstract(不管你写不写，默认都是这两个修饰符修饰)*（但是在JDK9中，接口可以有普通方法）
		*接口中的成员变量全都默认是public static final修饰的*
		*抽象类是is-a关系，接口是like-a关系，组合是has-a关系*
		*接口中没有构造器，所以只能通过创建类来实现此接口，通过该类的实例来调用类似接口中的抽象方法的实现方法

		*默认的构造器是public的
		*静态方法被重写时，当如下调用时：Father father = new Son(); father.m1()(m1是静态方法)此时调用的是father类中的m1方法不再调用子类里的重写方法m1（类似于双亲委托机制）
		*final 修饰成员变量时，必须显示初始化，否则编译报错*
