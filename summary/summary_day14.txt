2019，8.7：
	*多态：编译看左边，运行看左边（适用于成员变量（包括静态和非静态）和静态方法）
		   编译看左边，运行看右边（适用于实例方法）
		   但都得先看左边
	*泛型：Student<String>,Student<Integer>可以看成同一个类的不同形式
	
	*泛型通配符：当不能确定给泛型参数传递什么实际的类型时，可以使用通配符“<?>”
	来表示具体的泛型参数(<T>与<?>有啥区别）
	
	*泛型限定：
		泛型上限：所传递的泛型参数的类型只能是指定的类型的本身或者其子类类型；
			<? extends 上限类型>
		泛型下限：所传递的泛型参数的类型只能是指定的类型的本身或者其父类类型；	
		
		集合中关于泛型通配符与泛型限定的特殊情况
		
	*枚举：[enum/Enum]：是Java中类的一种，但是这种类的对象的个数是有限个；
		   单例模式：一个类只能产生一个对象，不管这个类有多少使用者在使用，这些使用者获取到
		   的对象都是同一个对象；
		   定义单例模式（可以利用静态性质只生成一个该类对象）：
				*构造器私有化*
				*提供公有的创建对象的方式
		
		自定义枚举类：关键字enum,枚举类是一种特殊的类，特殊在默认将构造器私有化了以及
		特殊在在枚举类中直接提供了该类的对象，并且对象是由public static final修饰的；自定义的枚举类
		默认继承自java.lang.Enum类（抽象类）；
		枚举类的产生对象语句放在第一句
		如果枚举类中有抽象方法，则需要该枚举类的每个对象都重写该抽象方法
		
			枚举类可以实现接口，但是不能继承自其他类【默认已经实现了Enum类】；枚举类实现
			接口之后需要重写接口的抽象方法，重写有两种形式：
				1.直接在类中重写，所有对象共用这个方法
				2.在每个对象上重写该方法
			枚举类可以定义多个构造器，构造器默认是private修饰，或者可以显式修饰
			
			当定义其他构造器时会覆盖默认的无参构造器，：
				1.显式定义无参构造器
				2.就在对象名后用其他构造器如：对象名（）{}（形式类似于匿名内部类）
	
	反射技术：1.java -> .class ------
			  2.Class 类：该类用于描述.class文件这类事物（即对java语言中的class的抽象描述）
			  
			  3.类加载机制：双亲委托机制--上行委托，下行加载
							类加载器：启动类加载器（jre/lib）--->扩展类加载器(jre/lib/ext)
							--->系统类加载器（classpath）--->网络类加载器--->(自定义类加载器)
			
			  4.获取一个类的Class对象（镜像）Class是个泛型类
					Class<Integer> ic = int.class;
			  
				1.通过调用某个类或者某个基本数据类型的.class属性；
				  Class<Integer> ic = int.class;
				  Class sc = Student.class
				2.通过某个类的对象调用.getClass()方法获取
					Teacher t = new X();(X是Teacher类的子类)
				  Class<? extends Teacher> sc = t.getClass();(t为对象名)
				3.通过类全名（包名.类名）【用于反射技术】
					String str = "类全名"
					Class<?> sc = Class.forName(str);
					
	心得：以前很少认真看java源码，一旦出错，就直接点击自己错误的地方跳转到对应位置，其实应该逐层看一下
		  控制台显示的跟这个错误相关的每一个跟源码相关的地方，看看源码是怎么写，对比自己的写法
		  从而按照java源码里的要求写，例如：没有实现Compareable接口的类，并且在创建TreeSet集合对象时没有传入实现Comparator接口的类的对象时，不能添加到TreeSet集合中去
		  这是我点击有关错误的java源码得出的结论