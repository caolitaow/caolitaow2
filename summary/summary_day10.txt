2019,8.1:
	static不能修饰局部变量
	*继承后，子类对象访问继承过来的成员时，实际上是委托父类对象去访问该成员，因为调用子类构造器时会默认先调用父类的构造器，即先创建父类对象（这个父类对象我们看不见）
	*主方法（程序入口）也能写在抽象方法里*
        *父类引用指向子类对象时，父类引用调用静态方法（子类重写了这个静态方法）时，实际调用了父类的静态方法，并没有调用子类的重写方法(并不是就近原则)*

	*上述的“重写”只是形式上的，那算隐藏（可以理解成隐藏了父类的静态方法即子类对象访问不到继承过来的静态方法了，但绝不是重写更不是覆盖）即静态方法是属于类的，父类引用虽然指向子类对象，但由于调用的是静态方法，此时运行就不看右边了，还看左边，即调用的是属于父类对象的静态方法
	6.内部类：
		成员内部类：
		1）在外部类的成员位置定义的类称为成员内部类
		2）要访问成员内部类里的成员必须先创建外部类的对象，然后调用内部类的构造器创建内部类的对象调用其成员，例如：new A().new B().show()

		3)外部类.this.x (在成员内部类里的成员方法内调用外部类里的成员时，可以这么去访问)

		4）内部类可以无条件访问外部类的成员

		静态内部类：
		1）成员内部类前加上static修饰
		2）静态内部类只能无条件访问外部类的静态成员
		3）外部类要访问静态内部类中的资源则需要创建内部类对象，但是由于内部类是静态，所以由外部类名直接调用静态内部类的构造器，而不用创建外部类对象，例如：A.B().show()
		4）this,super不能写在静态修饰的内容里
		
		还有这种用法：A.this.show()
		局部内部类：
		1）定义在方法中或者其他代码块中的类称之为局部内部类
		2）外部类访问局部内部类中的数据，先创建外部类对象，调用方法，让其先定义局部内部类，在该方法内创建局部内部类对象，用此对象访问局部内部类的数据；    局部内部类里访问外部类数据，无条件访问，如果局部内部类（静态内部类，成员内部类）中有和外部类或者该局部内部类所处的方法中同名的变量，则只能访问最新的同名变量

		3）方法入栈开始，出栈结束；如果局部内部类中访问到了该局部内部类所处的方法中的局部变量，则该变量必须使用final修饰，但是在jdk8中，该变量可以不显式的修饰，当在局部内部类中调用该变量时，则JVM默认就是final修饰的

		匿名内部类：
		1）没有名字的内部类，多用作实参进行参数传递
		2）通常情况下匿名内部类是借助于抽象类/接口使用，但也可以借助于普通类使用，例如：void go(new Car(){})这个匿名内部类可以是重写抽象类/接口，也可以是普通类的子类，JVM会给匿名内部类起名（其所在的外部类名$第几个匿名内部类@对象的内存地址）


	7.==和equals方法：
		1）两者都用于比较，返回值都是布尔类型的值
		2）==是运算符，equals是Object类中的方法
		3）==和equals在默认情况下都是比较两个对象的内存地址，若重写了Object类中的equals方法，则会按照重写的规则进行比较
		4) ==使用时只能比较引用类型与引用类型，基本数据类型与基本数据类型（但其它基本类型不能与boolean类型进行比较）而Object中的equals可以由所有引用类型变量调用，但不能由基本数据类型调用，但equals中的形参可以是任意数据类型
		5) 注意当调用equals方法的引用类型变量属于String类型，表明equals方法不能被修改（重写），因为String类被final修饰了
注意：非静态里可以访问静态成员，但是不能在非静态里定义静态成员，因为静态成员在非静态成员前就要加载。

