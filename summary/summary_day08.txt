2019,7.30:
知识点：	
	*方法的重载即方法名相同，形参不同
	
	*显示定义了构造器，默认的构造器就消失了

	*父类的私有成员可以被子类继承但不能直接访问

	*super,this必须位于构造器的第一句

        *类之间不能循环继承，同一个类里的构造器也不能循环调用

	*构造器不能被继承，调用子类的构造器时会默认只调用一次父类无参构造器，若父类没有无参构造器，则子类构造器必须显示调用父类有参的构造器，即调用子类构造器肯定会调用父类构造器

	*java继承是单继承，抽象类的话也只能继承一个（extends后面只能跟一个类），但可以实现多个接口

	*重载（方法名和参数列表相同即可）

	*重写方法（@Override表明底下的方法是重写方法；方法名相同，参数类型一致，数量相同，返回类型一样或者有继承关系，方法的访问权限不能缩小，异常不能被扩大）只发生在继承中：
		子类重写父类的方法后，调用方法时，根据就近原则调用当前类的方法，当然也可以用super显示调用父类的方法

	*多态（相同类型的不同对象调用同样方法时，会产生不同效果）（父类引用指向子类对象时）：编译时看父类（“目录”）里有无要运行的方法，有的话编译不会出错，运行时就看父类引用指向的是哪个子类，若该子类重写了此方法，就调用子类的重写方法，没有就调用父类（声明的类型）的方法

	*子类对象借着继承过来的public方法去访问自己继承过来的父类的私有属性，下面的this指的是子类对象就说明了子类继承了父类的私有属性只是不能直接访问
   	*子类对象通过继承父类的公有方法，去访问自己继承过来的私有属性，相当于得到了父类的授权，虽然子类继承了父类除构造器以外的成员，但父类可以通过设置有限的公有方法来限制子类对象访问继承过来的成员，若父类没有提供访问私有属性对应的公有或者受保护的方法，子类对象就无法使用继承过来的私有成员

	*不管是静态方法还是非静态方法，都不能在里面定义静态变量，静态变量可以直接定义在类里作为实例变量，可以定义在抽象类，接口中

	*一个类（包括抽象类）能既实现接口又继承抽象类，抽象类之间，接口之间也能相互继承

	*抽象类也能继承具体类*

	*执行优先级：静态代码块 > 代码块 > 构造方法*
	
	*jvm初始化某类的实例变量在调用该类构造方法之前*

体会：
	今天进一步熟悉了IDEA的使用，巩固了一遍java面向对象的三大特征：继承，封装，多态的相关知识点
