2019，9.23：
#
	挂载
	mysql语句的执行过程
	学习事务，总结提高查询效率的方式
	建一个mavn项目

@
	挂载：
		*挂载的是网络文件系统NFS【当然也可以挂载其他存储设备】，即被挂载的服务器需要安装
		rpcbind和nfs-server【nfc是基于rpc协议运行的】，挂载的本机要安装nfs-client【客户端和服务端软件版本最好一致，不一致
		的情况，我也没试过】
		
		*服务器需要在/etc/exports文件上添加/share 192.168.239.135(rw,async,no_subtree_check)
		...【配置文件中一般都有样例】
			/share  表示要被挂载的目录【创建共享目录时，需要指定用户：
										setfacl -m u:caolitao:rwx /share】
			
			
			192.168.239.135(rw,async,no_subtree_check) 要挂载的客户端的ip地址和()里相应的配置
			
			要挂载的客户端有多个的话就依次写在后面，之间用空格隔开
			
		*在客户端以root身份执行mount -t nfs -o soft 192.168.239.138:/share【ip为服务器的ip】 /mnt
		【将服务器端的/share挂载到了本机的/mnt目录上，此时server的/share等同于客户端的/mnt】
		
		*showmount -e 【或者输入exportfs】会显示该服务器的导出列表，也就是哪个目录被那台主机挂载了
					若没有显示，可能是配置文件没有生效，重启服务器即可
		 
	mysql事务：
	
			*事务主要用来管理 insert,update,delete 语句
			
			！select语句不会自动提交事务，增删改语句会自动提交事务
			
			
			
			！！即同一个会话【session】中事务即使不提交，也能看到更新后的数据！
			因为默认情况下事务的隔离级别是repeatable read；即当你手动开启事务后，在手动提交前
			所做的更改是在数据库文件上生效的【实际上只要增删改后内存里新的数据就会立马同步到数据库
			文件上】，但此时看到的新数据并不是直接来自于数据库文件，而是来自于内存。
			
			至于为什么没手动提交(commit)，数据库文件也被更新了，但别的事务又读不到更新后的数据
			主要是因为事务的隔离级别，还有脏读的产生，！详情见下个文件
			
			既然未手动提交，也能读到数据【脏读】，就说明手动commit之前数据就已经写到数据库文件
			上了，只是事务的隔离级别和手动commit让你读不读得到的问题
			
			！即另一个会话中读不到不代表没写进去，但没写进去一定读不到
			
			
			**猜想：mysql更改数据是先更改内存中的数据，再更改数据库文件里的数据？
			
			**答：猜想基本成立，事务提交前，数据和对数据的更改是放在缓存中的，当然，在事务执行过程中，修改数据
				时会不断产生redo日志（write ahead log），这些日志会写入redo日志文件。（在提交成功后，
				事务会确保所修改的数据的redo是持久化的。这样即使宕机了，也可以通过redo恢复出来。）？
			
			
			！！可以这么理解：事务的生命周期就相当于数据占用有关内存的时间，默认情况下事务都是自动提交的
							  即数据在有关内存中停留的时间就是数据操作在数据库文件完整生效的时间，当用户
							  按enter键执行增删改语句后，内存中的相关数据就消失了，用户感觉不到数据在内存中
							  
							  手动开启事务后需要手动提交，这就相当于延长了数据及数据的更改在内存中的时间
							  例如：
							    以下结果是建立在事务的隔离级别是repeatable read的基础上的
								session1:
									start transaction;
									select * from temp where id = 14;
									内存中
									
									update temp set name = 'xx' where id =14;
									
									select * from temp where id = 14;//查询的结果是更新后的结果
									
									commit;//提交后，源数据【数据库文件】的更新才会被读到
								
								session2:
									select * from temp where id = 14;//在另一个连接/会话中，只有当session1
									中的事务提交后，才能读到更新后的结果
							  
			
			
			
			【*额外收获：【这里的查询缓存指的是用来存放key-value的内存】
				1.建立一次到mysql数据库的连接的过程复杂，故尽量减少连接次数，也就是所谓的
				长连接，但长连接在长时间的运行后，会占用大量内存【执行mysql语句临时使用的内存被连接对象管理
				，当连接断开，连接对象也没了，内存才被释放】，在mysql5.7及以上版本可以执行
				mysql_reset_connection，在不重连和不重新验证权限的情况下，将连接恢复到新建时的状态，
				更低版本就需要断开重连了；
			
				2.当显示指定从查询缓存中查询数据【select SQL_CACHE * from temp where id=1】时，
				会先在缓存中看看是否有对应查询语句key,若有则直接返回给客户端对应的value查询结果，没有再
				从数据文件中找，命中缓存的话，查询效率会很高。
				
				！！！！事务手动开启后，在事务里的select语句，会用类似于查询缓存机制，优先从内存匹配相应的数据
				不在事务里写的select默认情况下不用这种机制，而是直接去数据库文件中查找。
				
				因为当更改了数据库文件时，为了命中缓存的查询结果的正确性，会清空缓存，重新给缓存
				添加数据，因此对于经常更新的数据库来说，命中缓存的概率很低，不如不用这种方式，还能
				节省点内存
				
			】
			
			
	
	mysql的大致执行过程【一般不涉及到查询缓存】：
		
			1.分析器【分析要做什么】：词法分析器，语法分析器
			2.优化器【考虑怎么做】：在表里面有多个索引的时候，决定使用哪个索引；
					  或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序
			3.执行器【执行sql语句】：执行器就会根据表的引擎定义，去使用这个引擎提供的接口。
	
	
	
	
	jdbc：
		*rs.updateString(2,"wangwu");rs.updateRow();【String对应的是数据库表里列的类型，是不固定的】 rs是被创建的结果集对象，更改结果集中当前记录的值
		改成wangwu
		
			*想要结果集可更改，需要在创建结果集对象时，在构造器里指定Result.TYPE_SCROLL_INSENSITIVE
			Result.CONCUR_UPDATABLE即在查询过程中,java程序将结果集【满足条件的所有记录】
			装到内存中，我们看到的是内存中的数据，此时【程序还在运行】
			更改数据库的数据，当程序运行结束后，显示的结果是更改前的结果，这就是所谓的不敏感
			
			*java并没有实现Result.TYPE_SCROLL_SENSITIVE【跟不敏感的主要区别就是装入内存中的只有主键值】
			【当指定Result.TYPE_SCROLL_SENSITIVE，java程序查询满足条件的数据时，应该是根据
			主键值到数据库文件【磁盘上】上找到对应的数据】
			
			
		*结果集指针默认指在第一条记录的前一个位置
		 rs.first()将结果集指针定位到第一条记录
		 rs.last()将结果集指针定位到最后一条记录
		
		
		**当Statement对象执行addBatch();后，会将之前设置好的所有Statement对象加入”批“中，通过
		executeBatch()将批中的操作做一次处理，一般用取余操作来分批，分批处理数据【一般指插入】
		可以提高处理效率
	
	
		**各种时间对象之间的转换靠的是时间戳
			Timestamp s = new Timestamp(new Date().getTime());
	
		*PreparedStatement对象调用的setDate(3,new java.sql.Date(new Date().getTime()))设置的
		是java.sql.date
	
		*连接对象调用setAutoCommit(false);自动提交关闭，需要调用commit();手动提交
	
	
	
	











